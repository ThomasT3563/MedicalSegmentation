#!/usr/bin/env python
# coding: utf-8

# In[ ]:

import tensorflow as tf
import SimpleITK as sitk
import os
import sys
import numpy as np
import glob
import imageio
import scipy.ndimage
import logging
import matplotlib.pyplot as plt
from logging.handlers import RotatingFileHandler
from os.path import basename,splitext

def display_learning_curves(history):
    """
        Display curves from history generated by training.fit
    """

    keys = list(history.history.keys())
    
    for key in keys[:len(keys)//2]:
        plt.plot(history.history[key])
        plt.plot(history.history['val_'+key])
        plt.title('model '+key)
        plt.ylabel(key)
        plt.xlabel('epoch')
        plt.legend(['train', 'test'], loc='upper left')
        plt.show()
    
    return None   

def create_gif(filenames,duration,path_gif):
    """
        From a list of images, generates gif
    """
    images = []
    for filename in filenames:
        images.append(imageio.imread(filename))
        
    name = splitext(basename(filenames[0][:-2]))[0]
    output_file = path_gif+'/GIF_'+name+'.gif'
    imageio.mimsave(output_file, images, duration=duration)
    
    return None

def create_MIP_projection(filenames,path_gif,borne_max=1.0):
    """
        From a NIFTI file filename, generates rotation MIP img .jpg
        and generates gif associated
    """
    
    duration = 0.1
    number_of_img = 60
    angle_filenames = []
    
    for filename in filenames:
    
        print("\nGeneration gif patient: %s" % basename(filename))
    
        raw_filename = splitext(basename(filename))[0]
        img = sitk.GetArrayFromImage(sitk.ReadImage(filename))

        for i,angle in enumerate(np.linspace(0,360,number_of_img)):
            
            #definition of loading bar
            length = round((i+1)/number_of_img*30)
            loading_bar = "["+"="*length+">"+"-"*(30-length)+"]"
            sys.stdout.write("\r%s/%s %s" % (str(i+1),str(number_of_img),loading_bar))

            vol_angle= scipy.ndimage.interpolation.rotate(img,angle,reshape=False,axes=(2, 1))
            MIP = np.amax(vol_angle,axis=1)

            f = plt.figure(figsize=(10,10))
            axes = plt.gca()
            plt.imshow(MIP,cmap='Greys',origin='lower',vmax=borne_max)
            axes.set_axis_off()
            angle_filename = path_gif+'/'+raw_filename+"."+str(int(angle))+".png"
            angle_filenames.append(angle_filename)
            f.savefig(angle_filename, bbox_inches='tight')

            plt.close()

        create_gif(angle_filenames, duration, path_gif)
        
    return None

def create_logger():
    
    logger = logging.getLogger()
    
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)

    logger.setLevel(logging.DEBUG)

    formatter = logging.Formatter('%(asctime)s :: %(levelname)s :: %(message)s')
    file_handler = RotatingFileHandler('activity.log', 'a', 1000000, 1)
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    stream_handler = logging.StreamHandler()
    stream_handler.setLevel(logging.INFO)
    logger.addHandler(stream_handler)
    return logger

def check_files(path):
    """
        Check if the folder at path exist
        
        Check if preprocessed data are well defined:
            - number of mask / scan
            - plotting MIP of images
    """
    if not os.path.isdir(path):
        sys.exit('There is no folder '+str(path))
    else:
        
        """
        Check if preprocessed data are well defined:
            - number of mask / scan
            - pairs of matchings characters
            - plotting MIP of images
        """
        filenames_masks = np.sort(glob.glob(path+'/**/*.nrrd'))
        filenames_scans = np.sort(glob.glob(path+'/**/*.nii'))

        check_Number_MaskScan(filenames_masks,filenames_scans)
        check_ShapeDtype_MaskScan(filenames_masks,filenames_scans)
        
        BUFFER_SIZE = len(filenames_scans)
        SHAPE_IMAGE = tf.expand_dims(tf.constant(sitk.GetArrayFromImage(sitk.ReadImage(filenames_scans[0],sitk.sitkFloat32 )),dtype=tf.float32),axis=-1).shape
        
    return BUFFER_SIZE, SHAPE_IMAGE

def check_Number_MaskScan(filenames_masks,filenames_scans):
    """
        Check number of masks and scans defined
    """
    nb_M = len(filenames_masks)
    nb_S = len(filenames_scans)
    
    assert(nb_M==nb_S), "Different number of mask and scans: %s / %s" % (nb_M,nb_S)
    assert(nb_M>0), "No masks are found"
    assert(nb_S>0), "No masks are found"

    return None

def check_ShapeDtype_MaskScan(filenames_masks,filenames_scans):
    """
        Check shape and dtype of masks and scans defined
    """
    
    mask = sitk.GetArrayFromImage(sitk.ReadImage(filenames_masks[0]))
    scan = sitk.GetArrayFromImage(sitk.ReadImage(filenames_scans[0]))
    
    shape = mask.shape
    dtype_scan = scan.dtype
    dtype_mask = mask.dtype
    
    print("Checking files...")
    print("Type mask: %s" % str(dtype_mask))
    print("Type scan: %s" % str(dtype_scan))
    
    n_patient = len(filenames_masks)
    
    for i,(filename_mask,filename_scan) in enumerate(zip(filenames_masks,filenames_scans)):
        
        display_loading_bar(i,n_patient,add_char=basename(filename_scan)+'     ' )
        
        mask = sitk.GetArrayFromImage(sitk.ReadImage(filename_mask))
        scan = sitk.GetArrayFromImage(sitk.ReadImage(filename_scan))
        
        assert (shape==mask.shape), "Mask %s has shape %s != %s" % (filename_mask,str(mask.shape),str(shape))
        assert (shape==scan.shape), "Scan %s has shape %s != %s" % (filename_mask,str(scan.shape),str(shape))
        
        assert (dtype_mask==mask.dtype), "Mask %s has dtype %s != %s" % (filename_mask,str(mask.dtype),str(dtype_mask))
        assert (dtype_scan==scan.dtype), "Scan %s has dtype %s != %s" % (filename_mask,str(scan.dtype),str(dtype_scan))
        
    return None

def display_loading_bar(iteration,length,total_length_bar=30,add_char=None):
    """
        Display a loading bar with a iteration / length information
    """
    ac_length = round((iteration+1)/length*total_length_bar)
    loading_bar = "["+"="*ac_length+">"+"-"*(total_length_bar-ac_length)+"]"
    
    if add_char:
        sys.stdout.write("\r%s/%s %s : %s" % (str(iteration+1),str(length),loading_bar,add_char))
    else:
        sys.stdout.write("\r%s/%s %s" % (str(iteration+1),str(length),loading_bar))
        
    return None

